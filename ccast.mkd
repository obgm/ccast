---
coding: utf-8

title: >
  Constrained-Cast: Source-Routed Multicast for RPL
abbrev: Constrained-Cast
docname: draft-bergmann-bier-ccast-00
date: 2014-11-09
category: std

ipr: trust200902
area: Applications
#workgroup: ACE Working Group
#keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs, compact]

author:
 -
    ins: O. Bergmann
    name: Olaf Bergmann
    organization: Universität Bremen TZI
    street: Postfach 330440
    city: Bremen
    code: D-28359
    country: Germany
    phone: +49-421-218-63904
    email: bergmann@tzi.org
 -
    ins: C. Bormann
    name: Carsten Bormann
    org: Universität Bremen TZI
    street: Postfach 330440
    city: Bremen
    code: D-28359
    country: Germany
    phone: +49-421-218-63921
    email: cabo@tzi.org
 -
    ins: S. Gerdes
    name: Stefanie Gerdes
    org: Universität Bremen TZI
    street: Postfach 330440
    city: Bremen
    code: D-28359
    country: Germany
    phone: +49-421-218-63906
    email: gerdes@tzi.org

normative:
  RFC2119:

informative:
  BLOOM:
    author:
    - ins: "B. H. Bloom"
      name: "Burton H. Bloom"
    seriesinfo:
      ISSN: "0001-0782"
      "ACM Press": "Communications of the ACM vol 13 no 7 pp 422-426"
    title: "Space/time trade-offs in hash coding with allowable errors"
    target: "http://doi.acm.org/10.1145/362686.362692"
    date: 1970

entity:
        SELF: "[RFC-XXXX]"

--- abstract

This specification defines a protocol for forwarding multicast traffic
in a constrained node network employing the RPL routing protocol in
non-storing mode.

--- middle


# Introduction

As defined in {{!RFC6550}}, RPL Multicast assumes that the RPL network
operates in Storing Mode.  Multicast DAOs are used to indicate
subscription to multicast address to a parent; these DAOs percolate up and create bread-crumbs.
This specification, although part of RFC 6550, appears to be
incomplete and untested.
More importantly, Storing Mode is not in use in constrained node
networks outside research operating environments.

The present specification addresses multicast forwarding for RPL
networks in the much more common Non-Storing Mode.  Non-Storing is
based on the root node adding source-routing information to downward
packets.  Evidently, to make this work, RPL multicast needs to
source-route multicast packets.  A source route here is a list of
outgoing interfaces, which subsets the whole set of potential forwarders
available in the RPL DODAG to those that need to forward in order to
reach known multicast listeners.

Including an actual list of outgoing interfaces is rarely applicable,
as this is likely to be a large list of 16-byte IPv6 addresses.
Even with {{?RFC6554}} style compression, the size of the list becomes
prohibitively quickly.

## Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 {{RFC2119}}.

# The BIER Approach

Bit-Indexed Explicit Replication {{?I-D.wijnands-bier-architecture}}
lists all egress routers in a bitmap included in each multicast
packet.  This requires creating a mostly contiguous numbering of all
egress routers; more importantly, BIER requires the presence of a
network map in each forwarders to be able to interpret the bitmap and
map it to a set of local outgoing interfaces.

# The Constrained-Cast Approach

Constrained-Cast employs Bloom Filters [BLOOM] as a compact representation of
a match or non-match for elements in a large set:
Each element to be included is hashed with multiple hash functions;
the result is used to index a bitmap and set the corresponding bit.
To check for the presence of an element, the same hash functions are
applied to obtain bit positions; if all corresponding bits are set,
this is used to indicate a match.
(Multiple hash functions are most easily obtained by adding a varying
seed value to a single hash algorithm.)

By including a bloom filter in each packet that matches all outgoing
interfaces that need to forward the packet, each forwarder can
efficiently decide whether (and on which interfaces) to forward the packet.

# False Positives

Bloom filters are probabilistic.  A false positive might be
indicating a match where the bits are set by aliasing of the hash
values.
In case of Constrained-Cast, this causes spurious transmission and
wastes some energy and radio bandwidth.
However, there is no semantic damage (hosts still filter out unneeded multicasts).
The total waste in energy and spectrum can be visualized as the
false-positive-rate multiplied by the density of the RPL network.
A network can easily live with a significant percentage of false positives.
By changing the set of hash functions (i.e., seed) over time, the
root can avoid a single node with a false positive to become an
unnecessary hotspot for that multicast group.

# Protocol

The protocol uses DAO-like "MLAO" messages to announce membership to
the root.  (To do: write up the format, which should be pretty much
obvious anyway.)

For downward messages, the root adds a new routing header that
includes a hash function identifier and a seed value; another one of
its fields gives the number of hash functions (k) to ask for k
instances of application of the hash function, with increasing seed.

Typical sizes of the bloom filter bitmap that the root inserts into
the packet can be 64, 128, or 256 bit, with acceptable false positive
rates for total numbers of forwarders in the 10s and 100s.  (To do:
write more about the math here.  Note that this number tallies
forwarding routers, not end hosts.)

A potential forwarder that receives a multicast packet adorned with a
constrained-cast routing header first checks that the packet is marked
with a RPL rank smaller than its own (loop prevention).  If yes, it
then forwards the packet to all outgoing interfaces that match the
bloom filter in the packet.

# Implementation

In 2013, Constrained-Cast was implemented in Contiki.  It turns out
that forwarders can compute the hash functions once for their outgoing
interfaces and then cache them, simply bit-matching their outgoing
interface hash bits against the bloom filter in the packet (a match is
indicated when all bits in the outgoing interface hash are set in the
bloom filter).

The Root computes the tree for each multicast group, computes the
bloom filter for it, caches these values, and then simply adds the
bloom filter routing header to each downward packet.  For adding a new
member, the relevant outgoing interfaces are simply added to the bloom
filter.  For removing a leaving member, however, the bloom filter
needs to be recomputed (which can be sped up logarithmically if
desired).

# Benefits

Constrained-Cast:

 * operates in Non-Storing Mode, with the simple addition of a
   membership information service;
 * performs all routing decisions at the root.

Further optimizations might include using a similar kind of bloom
filter routing header for unicast forwarding as well (representing,
instead of the outgoing interface list, a list of children that
forwarding parents need to forward to).

# Acknowledgments

This work has been supported by Siemens Corporate Technology.

<!--  LocalWords:  Datagram CoAP CoRE DTLS DCAF DCAF's introducer URI
 -->
<!--  LocalWords:  namespace Verifier JSON timestamp timestamps PSK
 -->
<!--  LocalWords:  decrypt UTC decrypted whitespace preshared HMAC
 -->
<!--  LocalWords:  multicast RPL
 -->
